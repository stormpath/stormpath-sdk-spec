### SAuthc1 Algorithm

Stormpath also supports a more secure authentication scheme known as digest authentication. This approach computes a [cryptographic digest](http://en.wikipedia.org/wiki/Cryptographic_hash_function) of the request and sends the digest value along with the request. If the transmitted digest matches what the Stormpath API server computes for the same request, the request is authenticated.

The SAuthc1 sign algorithm is similar in theory to [AWS signing algorithm](http://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html) in which parts of the request (query params, headers, etc) are signed using the API Key and API Secret and that signature is sent in the request as the Authorization header.

The reference implementation is the one defined in the [Stormpath Java SDK](https://github.com/stormpath/stormpath-sdk-java/blob/master/impl/src/main/java/com/stormpath/sdk/impl/http/authc/SAuthc1RequestAuthenticator.java). 

### Workflow

1.  The following headers need to be added to the request before signing the request: HOST and a custom Stormpath header X-Stormpath-Date set to the current date in the format yyyyMMddTHHmmssZ
2.  Generate a canonical request string which is composed of:
    + The request method (GET, POST, PUT, DELETE, etc.)
    + A new line
    +   The canonical resource path which is generated by encoding the request path.  If the path is empty then "/" should be used, otherwise URL encode the path then replace the following character sequences:
        + \+ to %20
        + \*  to %2A
        + %7E back to ~
        + %2F back to /
    + A new line
    + The canonical query string which is generated by appending each query param ordered by the param name like so: param=value&param2=value. Each param name should be in lower case and each param name and param value should be URL encoded and then the following character sequences need to be replaced:
        + \+ to %20
        + \*  to %2A
        + %7E back to ~
    + A new line
    + The canonical headers string which is generated by appending each header key and value ordered by header key in the following format: **header:headerValue1(new line)header2:headerValue**. Each header key needs to be in lower case.
    + A new line
    + A string of the headers that are part of the signature in the following format: **header;header2;header3**. The header keys should be in order and each key should be in lower case.
    + A new line
    + The sha256 hash of the request body in hexadecimal
3. Generate the string that's going be signed with the following format:
    + The algorithm string "HMAC-SHA-256"
    + A new line
    + The same timestamp use in the X-Stormpath-Date header
    + A new line
    + An id string compose of API_KEY_ID + "/" dateStamp (same date as the X-Stormpath-Date in format yyyyMMdd) + "/" a nonce string unique to every request (usually a UUID) + "/" + "sauthc1_request"
    + A new line
    + The canonical request from step 2 in hexadecimal
4. Generate the signature bytes.  Every sign step uses HMAC-SHA-256 algorithm
    + Generate the secret by concatenating "SAuthc1" + the API_KEY_SECRET
    + Sign the dateStamp used in step 3.e with the secret from step a
    + Sign the nonce from used in step 3.e with the signature from step b
    + Sign the "sauthc1_request" string using the signature from step c
    + Sign the string from step 3 using the signature from step d
5. Generate the Authorization header with the following value "SAuthc1" + " " + "sauthc1SignedHeaders" + "=" + the string from step 2.i  + ", " + "sauthc1Signature" + "=" +  the signature from step 4 in hexadecimal

### Caveats
    
+  String manipulation should be in UTF-8

### Pseudo code implementation

```javascript
const IDTerminator         = "sauthc1_request"
const Algorithm            = "HMAC-SHA-256"
const AuthenticationScheme = "SAuthc1"
const SAUTHC1Id            = "sauthc1Id"
const SAUTHC1SignedHeaders = "sauthc1SignedHeaders"
const SAUTHC1Signature     = "sauthc1Signature"
 
function sauthc1(request HttpRequest, credentials StormpathCredentials) {
    var currentDateTime = now()
    var dateTimeStr = currentDateTime.format("yyyyMMddTHHmmssZ")
    var dateStr = currentDateTime.format("yyyyMMdd")
    var nonce = newRandomString()
    var signedHeadersString = signedHeadersString(request.Headers)
    var canonicalRequest = request.method.toUpperCase() +
                            "\n" +
                            canonicalizeResourcePath(request.URL.Path) +
                            "\n" +
                            canonicalizeQueryString(request.QueryParams) +
                            "\n" +
                            canonicalizeHeadersString(request.Headers) +
                            "\n" +
                            signedHeadersString +
                            "\n" +
                            hash256Hex(request.body)
    var id = credentials.API_KEY_ID + "/" dateStr + "/" + nonce + IDTerminator
    var stringToSign = Algorithm +
                        "\n" +
                        dateTimeStr +
                        "\n" +
                        id +
                        hash256Hex(canonicalRequest)
    var secret = AuthenticationScheme + credentials.API_KEY_SECRET
    var signDate = hmacSha256Sign(dateStr, secret)
    var signNocne = hmacSha256Sign(nonce signDate)
    var signing = hmacSha256Sign(IDTerminator, signNocne)
    var signature = hmacSha256Sign(stringToSign, signing)
    authorizationHeader = AuthenticationScheme + SAUTHC1Id + "=" + id + ", " +
                            SAUTHC1SignedHeaders + "=" + signedHeadersString + ", " +
                            SAUTHC1Signature + "=" + hex(signature)
    request.Headers.add("Authorization", authorizationHeader)
}
function canonicalizeHeadersString(headers HttpRequestHeaders) {
    var resultString = ""
    var headerNamesArray = sort(headers.Names)
    for headerName in headerNamesArray {
        resultString = concat(resultString, headerName.toLowerCase())
        resultString = concat(resultString, ":")
        var first = true
        for headerValue in headers.values(headerName) {
            if !first {
                resultString = concat(resultString, ",")
            }
            resultString = concat(resultString, headerValue)
            first = false
        }
        resultString = concat(resultString, "\n")
    }
    return resultString
}
function canonicalizeQueryString(queryParams HttpRequestQueryParams) {
    var resultString = ""
    var paramNamesArray = sort(queryParams.Names)
    for paramName in paramNamesArray {
        var name = encodeURL(paramName, false true)
        for value in queryParams.values(name) {
            var val = encodeURL(value, false, true)
            if resultString.length > 0 {
                resultString = concat(resultString, "&")
            }
            resultString = concat(name, concat("=", val))
        }
    }
    return resultString
}
function signedHeadersString(headers HttpRequestHeaders) {
    var resultString = ""
    var headerNamesArray = sort(headers.Names)
    for headerName in headerNamesArray {
        if resultString.length > 0 {
            resultString = concat(resultString, ";")
        }
        resultString = concat(resultString, headerName.toLowerCase())
    }
    return resultString
}
function canonicalizeResourcePath(path String) {
    if path.length == 0 {
        return "/"
    }
    return encodeURL(path, true, true)
}
function encodeURL(value String, path Bool, canonical Bool) {
    if value == "" {
        return ""
    }
    var encoded = QueryEscape(value)
    if canonical {
        encoded = Replace(encoded, "+", "%20", -1)
        encoded = Replace(encoded, "*", "%2A", -1)
        encoded = Replace(encoded, "%7E", "~", -1)
        if path {
            encoded = Replace(encoded, "%2F", "/", -1)
        }
    }
    return encoded
}

```